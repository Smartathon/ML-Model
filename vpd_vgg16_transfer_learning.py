# -*- coding: utf-8 -*-
"""VPD_vgg16_transfer_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10zmo8XnAsoIYXlLeNHeA-ab5Yf4hwJp6
"""

#This code is submitted for smartathon for Visual pollution detection using VGG-16 model with transfer learning approach

from google.colab import drive
drive.mount('/content/drive')

#import required libraries
import numpy as np
import pandas as pd
from keras.applications.vgg16 import VGG16
from keras.layers import Dense, Dropout, Flatten
from keras.models import Model
from keras.optimizers import Adam
from keras.preprocessing import image
from keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from PIL import Image
from sklearn.preprocessing import LabelBinarizer
from sklearn.preprocessing import LabelEncoder
from keras.preprocessing import image
from keras.applications.vgg16 import preprocess_input, decode_predictions
import cv2
from google.colab.patches import cv2_imshow

# Load the annotations from the CSV file
annotations = pd.read_csv("/content/drive/MyDrive/dataset/sample_train.csv")

# Extract the classes and file paths from the annotations
classes = annotations["name"].values
file_paths = annotations["image_path"].values

# Extract the bounding boxes from the annotations
bounding_boxes = annotations[["xmin", "ymin", "xmax", "ymax"]].values

# Load the images and their corresponding classes and bounding boxes
X = []
y = []
bboxes = []
for file_path, class_name, bbox in zip(file_paths, classes, bounding_boxes):
    img = Image.open("/content/drive/MyDrive/dataset/sample_images/" + file_path)
    img = img.resize((960, 960))
    X.append(np.array(img))
    y.append(class_name)
    bboxes.append(bbox)

# Convert the classes and bounding boxes to numpy arrays
num_classes = len(np.unique(y))
encoder = LabelEncoder()
y = encoder.fit_transform(y)
y = to_categorical(y, num_classes)
bboxes = np.array(bboxes)
print(num_classes)

# Split the data into training and validation sets
X_train, X_val, y_train, y_val, bboxes_train, bboxes_val = train_test_split(X, y, bboxes, test_size=1)

# Load the VGG16 model with pre-trained weights
base_model = VGG16(weights='imagenet', include_top=False, input_shape=(960, 960, 3))

# Add a new fully connected layer for the 11 classes
x = base_model.output
x = Flatten()(x)
x = Dense(1024, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(11, activation='softmax')(x)

# Create a new model with the new fully connected layer
model = Model(inputs=base_model.input, outputs=predictions)

# Freeze the layers of the base model
for layer in base_model.layers:
    layer.trainable = False

# Compile the new model
model.compile(optimizer=Adam(lr=0.001), loss='categorical_crossentropy', metrics=['accuracy'])

#labelling as binary
label_as_binary = LabelBinarizer()
train_y = label_as_binary.fit_transform(y_train)
print(np.unique(y_train))
print(y_train.shape)

# Train the model
model.fit(np.array(X_train),y_train, batch_size=5, epochs=10, validation_data=(np.array(X_val), np.array(y_val)))

# Save the model
model.save("vgg16_transfer_learning_model_1.h5")

#model prediction

# Extract the file paths from the annotations

annots = pd.read_csv("/content/drive/MyDrive/dataset/sample_train.csv"

file_paths = annots["image_path"].values

#for storing in CSV file
results = pd.DataFrame(columns=["class","image_path","name","xmax","xmin","ymax","ymin"])

# Load the test image

for file_path in file_paths:
    img = Image.open("/content/drive/MyDrive/dataset/sample_images/" + file_path)
    img = img.resize((960, 960))
    x = np.asarray(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)
    # Make predictions
    preds = model.predict(x)
    # Get the class with the highest probability
    predicted_class = np.argmax(preds)
    # Get the class label
    class_label = classes[predicted_class]
    #bounding box metrics
    bbox = bounding_boxes[predicted_class]
    # Get the bounding box coordinates
    xmin, ymin, xmax, ymax = bbox

    
    # Append the results to the dataframe
    results = results.append({"class": predicted_class,"image_path":file_path, "name": class_label, "xmax": xmax,"xmin": xmin,"ymax": ymax,"ymin": ymin}, ignore_index=True)
    results.to_csv("/content/drive/MyDrive/dataset/result.csv", index=False)